!function () {
    "use strict"; var e = { 546: function () { try { self["workbox:background-sync:7.0.0"] && _() } catch (e) { } }, 81: function () { try { self["workbox:core:7.0.0"] && _() } catch (e) { } }, 485: function () { try { self["workbox:expiration:7.0.0"] && _() } catch (e) { } }, 248: function () { try { self["workbox:precaching:7.0.0"] && _() } catch (e) { } }, 492: function () { try { self["workbox:routing:7.0.0"] && _() } catch (e) { } }, 154: function () { try { self["workbox:strategies:7.0.0"] && _() } catch (e) { } } }, t = {}; function s(a) { var r = t[a]; if (void 0 !== r) return r.exports; var i = t[a] = { exports: {} }, n = !0; try { e[a](i, i.exports, s), n = !1 } finally { n && delete t[a] } return i.exports } !function () {
        var e, t, a; let r, i, n, o, c, l; s(81); let h = (e, ...t) => { let s = e; return t.length > 0 && (s += ` :: ${JSON.stringify(t)}`), s }; class u extends Error { constructor(e, t) { super(h(e, t)), this.name = e, this.details = t } } let d = new Set, f = { googleAnalytics: "googleAnalytics", precache: "precache-v2", prefix: "workbox", runtime: "runtime", suffix: "undefined" != typeof registration ? registration.scope : "" }, p = e => [f.prefix, e, f.suffix].filter(e => e && e.length > 0).join("-"), w = e => e || p(f.precache), g = e => e || p(f.runtime); function y(e, t) { let s = new URL(e); for (let e of t) s.searchParams.delete(e); return s.href } async function m(e, t, s, a) { let r = y(t.url, s); if (t.url === r) return e.match(t, a); let i = Object.assign(Object.assign({}, a), { ignoreSearch: !0 }); for (let n of (await e.keys(t, i))) if (r === y(n.url, s)) return e.match(n, a) } function b(e) { e.then(() => { }) } class E { constructor() { this.promise = new Promise((e, t) => { this.resolve = e, this.reject = t }) } } async function R() { for (let e of d) await e() } let x = e => new URL(String(e), location.href).href.replace(RegExp(`^${location.origin}`), ""); function q(e) { return new Promise(t => setTimeout(t, e)) } function v(e, t) { let s = t(); return e.waitUntil(s), s } async function D(e, t) { let s = null; if (e.url && (s = new URL(e.url).origin), s !== self.location.origin) throw new u("cross-origin-copy-response", { origin: s }); let a = e.clone(), i = { headers: new Headers(a.headers), status: a.status, statusText: a.statusText }, n = t ? t(i) : i, o = !function () { if (void 0 === r) { let e = new Response(""); if ("body" in e) try { new Response(e.body), r = !0 } catch (e) { r = !1 } r = !1 } return r }() ? await a.blob() : a.body; return new Response(o, n) } let C = (e, t) => t.some(t => e instanceof t), S = new WeakMap, T = new WeakMap, k = new WeakMap, N = new WeakMap, L = new WeakMap, I = { get(e, t, s) { if (e instanceof IDBTransaction) { if ("done" === t) return T.get(e); if ("objectStoreNames" === t) return e.objectStoreNames || k.get(e); if ("store" === t) return s.objectStoreNames[1] ? void 0 : s.objectStore(s.objectStoreNames[0]) } return U(e[t]) }, set: (e, t, s) => (e[t] = s, !0), has: (e, t) => e instanceof IDBTransaction && ("done" === t || "store" === t) || t in e }; function U(e) { var t; if (e instanceof IDBRequest) return function (e) { let t = new Promise((t, s) => { let a = () => { e.removeEventListener("success", r), e.removeEventListener("error", i) }, r = () => { t(U(e.result)), a() }, i = () => { s(e.error), a() }; e.addEventListener("success", r), e.addEventListener("error", i) }); return t.then(t => { t instanceof IDBCursor && S.set(t, e) }).catch(() => { }), L.set(t, e), t }(e); if (N.has(e)) return N.get(e); let s = "function" == typeof (t = e) ? t !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? (n || (n = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])).includes(t) ? function (...e) { return t.apply(A(this), e), U(S.get(this)) } : function (...e) { return U(t.apply(A(this), e)) } : function (e, ...s) { let a = t.call(A(this), e, ...s); return k.set(a, e.sort ? e.sort() : [e]), U(a) } : (t instanceof IDBTransaction && function (e) { if (T.has(e)) return; let t = new Promise((t, s) => { let a = () => { e.removeEventListener("complete", r), e.removeEventListener("error", i), e.removeEventListener("abort", i) }, r = () => { t(), a() }, i = () => { s(e.error || new DOMException("AbortError", "AbortError")), a() }; e.addEventListener("complete", r), e.addEventListener("error", i), e.addEventListener("abort", i) }); T.set(e, t) }(t), C(t, i || (i = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]))) ? new Proxy(t, I) : t; return s !== e && (N.set(e, s), L.set(s, e)), s } let A = e => L.get(e); function P(e, t, { blocked: s, upgrade: a, blocking: r, terminated: i } = {}) { let n = indexedDB.open(e, t), o = U(n); return a && n.addEventListener("upgradeneeded", e => { a(U(n.result), e.oldVersion, e.newVersion, U(n.transaction), e) }), s && n.addEventListener("blocked", e => s(e.oldVersion, e.newVersion, e)), o.then(e => { i && e.addEventListener("close", () => i()), r && e.addEventListener("versionchange", e => r(e.oldVersion, e.newVersion, e)) }).catch(() => { }), o } let O = ["get", "getKey", "getAll", "getAllKeys", "count"], K = ["put", "add", "delete", "clear"], M = new Map; function B(e, t) { if (!(e instanceof IDBDatabase && !(t in e) && "string" == typeof t)) return; if (M.get(t)) return M.get(t); let s = t.replace(/FromIndex$/, ""), a = t !== s, r = K.includes(s); if (!(s in (a ? IDBIndex : IDBObjectStore).prototype) || !(r || O.includes(s))) return; let i = async function (e, ...t) { let i = this.transaction(e, r ? "readwrite" : "readonly"), n = i.store; return a && (n = n.index(t.shift())), (await Promise.all([n[s](...t), r && i.done]))[0] }; return M.set(t, i), i } I = { ...l = I, get: (e, t, s) => B(e, t) || l.get(e, t, s), has: (e, t) => !!B(e, t) || l.has(e, t) }, s(485); let j = "cache-entries", F = e => { let t = new URL(e, location.href); return t.hash = "", t.href }; class W { constructor(e) { this._db = null, this._cacheName = e } _upgradeDb(e) { let t = e.createObjectStore(j, { keyPath: "id" }); t.createIndex("cacheName", "cacheName", { unique: !1 }), t.createIndex("timestamp", "timestamp", { unique: !1 }) } _upgradeDbAndDeleteOldDbs(e) { this._upgradeDb(e), this._cacheName && function (e, { blocked: t } = {}) { let s = indexedDB.deleteDatabase(e); t && s.addEventListener("blocked", e => t(e.oldVersion, e)), U(s).then(() => void 0) }(this._cacheName) } async setTimestamp(e, t) { let s = { url: e = F(e), timestamp: t, cacheName: this._cacheName, id: this._getId(e) }, a = (await this.getDb()).transaction(j, "readwrite", { durability: "relaxed" }); await a.store.put(s), await a.done } async getTimestamp(e) { let t = await this.getDb(), s = await t.get(j, this._getId(e)); return null == s ? void 0 : s.timestamp } async expireEntries(e, t) { let s = await this.getDb(), a = await s.transaction(j).store.index("timestamp").openCursor(null, "prev"), r = [], i = 0; for (; a;) { let s = a.value; s.cacheName === this._cacheName && (e && s.timestamp < e || t && i >= t ? r.push(a.value) : i++), a = await a.continue() } let n = []; for (let e of r) await s.delete(j, e.id), n.push(e.url); return n } _getId(e) { return this._cacheName + "|" + F(e) } async getDb() { return this._db || (this._db = await P("workbox-expiration", 1, { upgrade: this._upgradeDbAndDeleteOldDbs.bind(this) })), this._db } } class H { constructor(e, t = {}) { this._isRunning = !1, this._rerunRequested = !1, this._maxEntries = t.maxEntries, this._maxAgeSeconds = t.maxAgeSeconds, this._matchOptions = t.matchOptions, this._cacheName = e, this._timestampModel = new W(e) } async expireEntries() { if (this._isRunning) { this._rerunRequested = !0; return } this._isRunning = !0; let e = this._maxAgeSeconds ? Date.now() - 1e3 * this._maxAgeSeconds : 0, t = await this._timestampModel.expireEntries(e, this._maxEntries), s = await self.caches.open(this._cacheName); for (let e of t) await s.delete(e, this._matchOptions); this._isRunning = !1, this._rerunRequested && (this._rerunRequested = !1, b(this.expireEntries())) } async updateTimestamp(e) { await this._timestampModel.setTimestamp(e, Date.now()) } async isURLExpired(e) { if (!this._maxAgeSeconds) return !1; { let t = await this._timestampModel.getTimestamp(e), s = Date.now() - 1e3 * this._maxAgeSeconds; return void 0 === t || t < s } } async delete() { this._rerunRequested = !1, await this._timestampModel.expireEntries(1 / 0) } } class Q { constructor(e = {}) { if (this.cachedResponseWillBeUsed = async ({ event: e, request: t, cacheName: s, cachedResponse: a }) => { if (!a) return null; let r = this._isResponseDateFresh(a), i = this._getCacheExpiration(s); b(i.expireEntries()); let n = i.updateTimestamp(t.url); if (e) try { e.waitUntil(n) } catch (e) { } return r ? a : null }, this.cacheDidUpdate = async ({ cacheName: e, request: t }) => { let s = this._getCacheExpiration(e); await s.updateTimestamp(t.url), await s.expireEntries() }, this._config = e, this._maxAgeSeconds = e.maxAgeSeconds, this._cacheExpirations = new Map, e.purgeOnQuotaError) { var t; t = () => this.deleteCacheAndMetadata(), d.add(t) } } _getCacheExpiration(e) { if (e === g()) throw new u("expire-custom-caches-only"); let t = this._cacheExpirations.get(e); return t || (t = new H(e, this._config), this._cacheExpirations.set(e, t)), t } _isResponseDateFresh(e) { if (!this._maxAgeSeconds) return !0; let t = this._getDateHeaderTimestamp(e); return null === t || t >= Date.now() - 1e3 * this._maxAgeSeconds } _getDateHeaderTimestamp(e) { if (!e.headers.has("date")) return null; let t = new Date(e.headers.get("date")).getTime(); return isNaN(t) ? null : t } async deleteCacheAndMetadata() { for (let [e, t] of this._cacheExpirations) await self.caches.delete(e), await t.delete(); this._cacheExpirations = new Map } } function $(e) { return "string" == typeof e ? new Request(e) : e } s(154); class G { constructor(e, t) { for (let s of (this._cacheKeys = {}, Object.assign(this, t), this.event = t.event, this._strategy = e, this._handlerDeferred = new E, this._extendLifetimePromises = [], this._plugins = [...e.plugins], this._pluginStateMap = new Map, this._plugins)) this._pluginStateMap.set(s, {}); this.event.waitUntil(this._handlerDeferred.promise) } async fetch(e) { let { event: t } = this, s = $(e); if ("navigate" === s.mode && t instanceof FetchEvent && t.preloadResponse) { let e = await t.preloadResponse; if (e) return e } let a = this.hasCallback("fetchDidFail") ? s.clone() : null; try { for (let e of this.iterateCallbacks("requestWillFetch")) s = await e({ request: s.clone(), event: t }) } catch (e) { if (e instanceof Error) throw new u("plugin-error-request-will-fetch", { thrownErrorMessage: e.message }) } let r = s.clone(); try { let e; for (let a of (e = await fetch(s, "navigate" === s.mode ? void 0 : this._strategy.fetchOptions), this.iterateCallbacks("fetchDidSucceed"))) e = await a({ event: t, request: r, response: e }); return e } catch (e) { throw a && await this.runCallbacks("fetchDidFail", { error: e, event: t, originalRequest: a.clone(), request: r.clone() }), e } } async fetchAndCachePut(e) { let t = await this.fetch(e), s = t.clone(); return this.waitUntil(this.cachePut(e, s)), t } async cacheMatch(e) { let t; let s = $(e), { cacheName: a, matchOptions: r } = this._strategy, i = await this.getCacheKey(s, "read"), n = Object.assign(Object.assign({}, r), { cacheName: a }); for (let e of (t = await caches.match(i, n), this.iterateCallbacks("cachedResponseWillBeUsed"))) t = await e({ cacheName: a, matchOptions: r, cachedResponse: t, request: i, event: this.event }) || void 0; return t } async cachePut(e, t) { let s = $(e); await q(0); let a = await this.getCacheKey(s, "write"); if (!t) throw new u("cache-put-with-no-response", { url: x(a.url) }); let r = await this._ensureResponseSafeToCache(t); if (!r) return !1; let { cacheName: i, matchOptions: n } = this._strategy, o = await self.caches.open(i), c = this.hasCallback("cacheDidUpdate"), l = c ? await m(o, a.clone(), ["__WB_REVISION__"], n) : null; try { await o.put(a, c ? r.clone() : r) } catch (e) { if (e instanceof Error) throw "QuotaExceededError" === e.name && await R(), e } for (let e of this.iterateCallbacks("cacheDidUpdate")) await e({ cacheName: i, oldResponse: l, newResponse: r.clone(), request: a, event: this.event }); return !0 } async getCacheKey(e, t) { let s = `${e.url} | ${t}`; if (!this._cacheKeys[s]) { let a = e; for (let e of this.iterateCallbacks("cacheKeyWillBeUsed")) a = $(await e({ mode: t, request: a, event: this.event, params: this.params })); this._cacheKeys[s] = a } return this._cacheKeys[s] } hasCallback(e) { for (let t of this._strategy.plugins) if (e in t) return !0; return !1 } async runCallbacks(e, t) { for (let s of this.iterateCallbacks(e)) await s(t) } *iterateCallbacks(e) { for (let t of this._strategy.plugins) if ("function" == typeof t[e]) { let s = this._pluginStateMap.get(t), a = a => { let r = Object.assign(Object.assign({}, a), { state: s }); return t[e](r) }; yield a } } waitUntil(e) { return this._extendLifetimePromises.push(e), e } async doneWaiting() { let e; for (; e = this._extendLifetimePromises.shift();)await e } destroy() { this._handlerDeferred.resolve(null) } async _ensureResponseSafeToCache(e) { let t = e, s = !1; for (let e of this.iterateCallbacks("cacheWillUpdate")) if (t = await e({ request: this.request, response: t, event: this.event }) || void 0, s = !0, !t) break; return !s && t && 200 !== t.status && (t = void 0), t } } class V { constructor(e = {}) { this.cacheName = g(e.cacheName), this.plugins = e.plugins || [], this.fetchOptions = e.fetchOptions, this.matchOptions = e.matchOptions } handle(e) { let [t] = this.handleAll(e); return t } handleAll(e) { e instanceof FetchEvent && (e = { event: e, request: e.request }); let t = e.event, s = "string" == typeof e.request ? new Request(e.request) : e.request, a = new G(this, { event: t, request: s, params: "params" in e ? e.params : void 0 }), r = this._getResponse(a, s, t), i = this._awaitComplete(r, a, s, t); return [r, i] } async _getResponse(e, t, s) { let a; await e.runCallbacks("handlerWillStart", { event: s, request: t }); try { if (!(a = await this._handle(t, e)) || "error" === a.type) throw new u("no-response", { url: t.url }) } catch (r) { if (r instanceof Error) { for (let i of e.iterateCallbacks("handlerDidError")) if (a = await i({ error: r, event: s, request: t })) break } if (a); else throw r } for (let r of e.iterateCallbacks("handlerWillRespond")) a = await r({ event: s, request: t, response: a }); return a } async _awaitComplete(e, t, s, a) { let r, i; try { r = await e } catch (e) { } try { await t.runCallbacks("handlerDidRespond", { event: a, request: s, response: r }), await t.doneWaiting() } catch (e) { e instanceof Error && (i = e) } if (await t.runCallbacks("handlerDidComplete", { event: a, request: s, response: r, error: i }), t.destroy(), i) throw i } } class z extends V { async _handle(e, t) { let s, a = await t.cacheMatch(e); if (!a) try { a = await t.fetchAndCachePut(e) } catch (e) { e instanceof Error && (s = e) } if (!a) throw new u("no-response", { url: e.url, error: s }); return a } } let J = { cacheWillUpdate: async ({ response: e }) => 200 === e.status || 0 === e.status ? e : null }; class X extends V { constructor(e = {}) { super(e), this.plugins.some(e => "cacheWillUpdate" in e) || this.plugins.unshift(J), this._networkTimeoutSeconds = e.networkTimeoutSeconds || 0 } async _handle(e, t) { let s; let a = [], r = []; if (this._networkTimeoutSeconds) { let { id: i, promise: n } = this._getTimeoutPromise({ request: e, logs: a, handler: t }); s = i, r.push(n) } let i = this._getNetworkPromise({ timeoutId: s, request: e, logs: a, handler: t }); r.push(i); let n = await t.waitUntil((async () => await t.waitUntil(Promise.race(r)) || await i)()); if (!n) throw new u("no-response", { url: e.url }); return n } _getTimeoutPromise({ request: e, logs: t, handler: s }) { let a; return { promise: new Promise(t => { a = setTimeout(async () => { t(await s.cacheMatch(e)) }, 1e3 * this._networkTimeoutSeconds) }), id: a } } async _getNetworkPromise({ timeoutId: e, request: t, logs: s, handler: a }) { let r, i; try { i = await a.fetchAndCachePut(t) } catch (e) { e instanceof Error && (r = e) } return e && clearTimeout(e), (r || !i) && (i = await a.cacheMatch(t)), i } } class Y extends V { constructor(e = {}) { super(e), this._networkTimeoutSeconds = e.networkTimeoutSeconds || 0 } async _handle(e, t) { let s, a; try { let a = [t.fetch(e)]; if (this._networkTimeoutSeconds) { let e = q(1e3 * this._networkTimeoutSeconds); a.push(e) } if (!(s = await Promise.race(a))) throw Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`) } catch (e) { e instanceof Error && (a = e) } if (!s) throw new u("no-response", { url: e.url, error: a }); return s } } class Z extends V { constructor(e = {}) { super(e), this.plugins.some(e => "cacheWillUpdate" in e) || this.plugins.unshift(J) } async _handle(e, t) { let s; let a = t.fetchAndCachePut(e).catch(() => { }); t.waitUntil(a); let r = await t.cacheMatch(e); if (r); else try { r = await a } catch (e) { e instanceof Error && (s = e) } if (!r) throw new u("no-response", { url: e.url, error: s }); return r } } s(492); let ee = e => e && "object" == typeof e ? e : { handle: e }; class et { constructor(e, t, s = "GET") { this.handler = ee(t), this.match = e, this.method = s } setCatchHandler(e) { this.catchHandler = ee(e) } } class es extends et { constructor(e, t, s) { super(({ url: t }) => { let s = e.exec(t.href); if (s && (t.origin === location.origin || 0 === s.index)) return s.slice(1) }, t, s) } } class ea { constructor() { this._routes = new Map, this._defaultHandlerMap = new Map } get routes() { return this._routes } addFetchListener() { self.addEventListener("fetch", e => { let { request: t } = e, s = this.handleRequest({ request: t, event: e }); s && e.respondWith(s) }) } addCacheListener() { self.addEventListener("message", e => { if (e.data && "CACHE_URLS" === e.data.type) { let { payload: t } = e.data, s = Promise.all(t.urlsToCache.map(t => { "string" == typeof t && (t = [t]); let s = new Request(...t); return this.handleRequest({ request: s, event: e }) })); e.waitUntil(s), e.ports && e.ports[0] && s.then(() => e.ports[0].postMessage(!0)) } }) } handleRequest({ request: e, event: t }) { let s; let a = new URL(e.url, location.href); if (!a.protocol.startsWith("http")) return; let r = a.origin === location.origin, { params: i, route: n } = this.findMatchingRoute({ event: t, request: e, sameOrigin: r, url: a }), o = n && n.handler, c = e.method; if (!o && this._defaultHandlerMap.has(c) && (o = this._defaultHandlerMap.get(c)), !o) return; try { s = o.handle({ url: a, request: e, event: t, params: i }) } catch (e) { s = Promise.reject(e) } let l = n && n.catchHandler; return s instanceof Promise && (this._catchHandler || l) && (s = s.catch(async s => { if (l) try { return await l.handle({ url: a, request: e, event: t, params: i }) } catch (e) { e instanceof Error && (s = e) } if (this._catchHandler) return this._catchHandler.handle({ url: a, request: e, event: t }); throw s })), s } findMatchingRoute({ url: e, sameOrigin: t, request: s, event: a }) { for (let r of this._routes.get(s.method) || []) { let i; let n = r.match({ url: e, sameOrigin: t, request: s, event: a }); if (n) return Array.isArray(i = n) && 0 === i.length ? i = void 0 : n.constructor === Object && 0 === Object.keys(n).length ? i = void 0 : "boolean" == typeof n && (i = void 0), { route: r, params: i } } return {} } setDefaultHandler(e, t = "GET") { this._defaultHandlerMap.set(t, ee(e)) } setCatchHandler(e) { this._catchHandler = ee(e) } registerRoute(e) { this._routes.has(e.method) || this._routes.set(e.method, []), this._routes.get(e.method).push(e) } unregisterRoute(e) { if (!this._routes.has(e.method)) throw new u("unregister-route-but-not-found-with-method", { method: e.method }); let t = this._routes.get(e.method).indexOf(e); if (t > -1) this._routes.get(e.method).splice(t, 1); else throw new u("unregister-route-route-not-registered") } } let er = () => (o || ((o = new ea).addFetchListener(), o.addCacheListener()), o); function ei(e, t, s) { let a; if ("string" == typeof e) { let r = new URL(e, location.href); a = new et(({ url: e }) => e.href === r.href, t, s) } else if (e instanceof RegExp) a = new es(e, t, s); else if ("function" == typeof e) a = new et(e, t, s); else if (e instanceof et) a = e; else throw new u("unsupported-route-type", { moduleName: "workbox-routing", funcName: "registerRoute", paramName: "capture" }); return er().registerRoute(a), a } s(248); class en { constructor() { this.updatedURLs = [], this.notUpdatedURLs = [], this.handlerWillStart = async ({ request: e, state: t }) => { t && (t.originalRequest = e) }, this.cachedResponseWillBeUsed = async ({ event: e, state: t, cachedResponse: s }) => { if ("install" === e.type && t && t.originalRequest && t.originalRequest instanceof Request) { let e = t.originalRequest.url; s ? this.notUpdatedURLs.push(e) : this.updatedURLs.push(e) } return s } } } class eo { constructor({ precacheController: e }) { this.cacheKeyWillBeUsed = async ({ request: e, params: t }) => { let s = (null == t ? void 0 : t.cacheKey) || this._precacheController.getCacheKeyForURL(e.url); return s ? new Request(s, { headers: e.headers }) : e }, this._precacheController = e } } class ec extends V { constructor(e = {}) { e.cacheName = w(e.cacheName), super(e), this._fallbackToNetwork = !1 !== e.fallbackToNetwork, this.plugins.push(ec.copyRedirectedCacheableResponsesPlugin) } async _handle(e, t) { return await t.cacheMatch(e) || (t.event && "install" === t.event.type ? await this._handleInstall(e, t) : await this._handleFetch(e, t)) } async _handleFetch(e, t) { let s; let a = t.params || {}; if (this._fallbackToNetwork) { let r = a.integrity, i = e.integrity, n = !i || i === r; s = await t.fetch(new Request(e, { integrity: "no-cors" !== e.mode ? i || r : void 0 })), r && n && "no-cors" !== e.mode && (this._useDefaultCacheabilityPluginIfNeeded(), await t.cachePut(e, s.clone())) } else throw new u("missing-precache-entry", { cacheName: this.cacheName, url: e.url }); return s } async _handleInstall(e, t) { this._useDefaultCacheabilityPluginIfNeeded(); let s = await t.fetch(e); if (!await t.cachePut(e, s.clone())) throw new u("bad-precaching-response", { url: e.url, status: s.status }); return s } _useDefaultCacheabilityPluginIfNeeded() { let e = null, t = 0; for (let [s, a] of this.plugins.entries()) a !== ec.copyRedirectedCacheableResponsesPlugin && (a === ec.defaultPrecacheCacheabilityPlugin && (e = s), a.cacheWillUpdate && t++); 0 === t ? this.plugins.push(ec.defaultPrecacheCacheabilityPlugin) : t > 1 && null !== e && this.plugins.splice(e, 1) } } ec.defaultPrecacheCacheabilityPlugin = { cacheWillUpdate: async ({ response: e }) => !e || e.status >= 400 ? null : e }, ec.copyRedirectedCacheableResponsesPlugin = { cacheWillUpdate: async ({ response: e }) => e.redirected ? await D(e) : e }; class el {
            constructor({ cacheName: e, plugins: t = [], fallbackToNetwork: s = !0 } = {}) { this._urlsToCacheKeys = new Map, this._urlsToCacheModes = new Map, this._cacheKeysToIntegrities = new Map, this._strategy = new ec({ cacheName: w(e), plugins: [...t, new eo({ precacheController: this })], fallbackToNetwork: s }), this.install = this.install.bind(this), this.activate = this.activate.bind(this) } get strategy() { return this._strategy } precache(e) { this.addToCacheList(e), this._installAndActiveListenersAdded || (self.addEventListener("install", this.install), self.addEventListener("activate", this.activate), this._installAndActiveListenersAdded = !0) } addToCacheList(e) {
                let t = []; for (let s of e) {
                    "string" == typeof s ? t.push(s) : s && void 0 === s.revision && t.push(s.url); let { cacheKey: e, url: a } = function (e) { if (!e) throw new u("add-to-cache-list-unexpected-type", { entry: e }); if ("string" == typeof e) { let t = new URL(e, location.href); return { cacheKey: t.href, url: t.href } } let { revision: t, url: s } = e; if (!s) throw new u("add-to-cache-list-unexpected-type", { entry: e }); if (!t) { let e = new URL(s, location.href); return { cacheKey: e.href, url: e.href } } let a = new URL(s, location.href), r = new URL(s, location.href); return a.searchParams.set("__WB_REVISION__", t), { cacheKey: a.href, url: r.href } }(s), r = "string" != typeof s && s.revision ? "reload" : "default"; if (this._urlsToCacheKeys.has(a) && this._urlsToCacheKeys.get(a) !== e) throw new u("add-to-cache-list-conflicting-entries", { firstEntry: this._urlsToCacheKeys.get(a), secondEntry: e }); if ("string" != typeof s && s.integrity) { if (this._cacheKeysToIntegrities.has(e) && this._cacheKeysToIntegrities.get(e) !== s.integrity) throw new u("add-to-cache-list-conflicting-integrities", { url: a }); this._cacheKeysToIntegrities.set(e, s.integrity) } this._urlsToCacheKeys.set(a, e), this._urlsToCacheModes.set(a, r), t.length > 0 && console.warn(`Workbox is precaching URLs without revision info: ${t.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`)
                }
            } install(e) { return v(e, async () => { let t = new en; for (let [s, a] of (this.strategy.plugins.push(t), this._urlsToCacheKeys)) { let t = this._cacheKeysToIntegrities.get(a), r = this._urlsToCacheModes.get(s), i = new Request(s, { integrity: t, cache: r, credentials: "same-origin" }); await Promise.all(this.strategy.handleAll({ params: { cacheKey: a }, request: i, event: e })) } let { updatedURLs: s, notUpdatedURLs: a } = t; return { updatedURLs: s, notUpdatedURLs: a } }) } activate(e) { return v(e, async () => { let e = await self.caches.open(this.strategy.cacheName), t = await e.keys(), s = new Set(this._urlsToCacheKeys.values()), a = []; for (let r of t) s.has(r.url) || (await e.delete(r), a.push(r.url)); return { deletedURLs: a } }) } getURLsToCacheKeys() { return this._urlsToCacheKeys } getCachedURLs() { return [...this._urlsToCacheKeys.keys()] } getCacheKeyForURL(e) { let t = new URL(e, location.href); return this._urlsToCacheKeys.get(t.href) } getIntegrityForCacheKey(e) { return this._cacheKeysToIntegrities.get(e) } async matchPrecache(e) { let t = e instanceof Request ? e.url : e, s = this.getCacheKeyForURL(t); if (s) return (await self.caches.open(this.strategy.cacheName)).match(s) } createHandlerBoundToURL(e) { let t = this.getCacheKeyForURL(e); if (!t) throw new u("non-precached-url", { url: e }); return s => (s.request = new Request(e), s.params = Object.assign({ cacheKey: t }, s.params), this.strategy.handle(s)) }
        } let eh = () => (c || (c = new el), c); class eu extends et { constructor(e, t) { super(({ request: s }) => { let a = e.getURLsToCacheKeys(); for (let r of function* (e, { ignoreURLParametersMatching: t = [/^utm_/, /^fbclid$/], directoryIndex: s = "index.html", cleanURLs: a = !0, urlManipulation: r } = {}) { let i = new URL(e, location.href); i.hash = "", yield i.href; let n = function (e, t = []) { for (let s of [...e.searchParams.keys()]) t.some(e => e.test(s)) && e.searchParams.delete(s); return e }(i, t); if (yield n.href, s && n.pathname.endsWith("/")) { let e = new URL(n.href); e.pathname += s, yield e.href } if (a) { let e = new URL(n.href); e.pathname += ".html", yield e.href } if (r) for (let e of r({ url: i })) yield e.href }(s.url, t)) { let t = a.get(r); if (t) { let s = e.getIntegrityForCacheKey(t); return { cacheKey: t, integrity: s } } } }, e.strategy) } } let ed = "-precache-", ef = async (e, t = ed) => { let s = (await self.caches.keys()).filter(s => s.includes(t) && s.includes(self.registration.scope) && s !== e); return await Promise.all(s.map(e => self.caches.delete(e))), s }; function ep(e) { return eh().matchPrecache(e) } s(546); let ew = "requests", eg = "queueName"; class ey { constructor() { this._db = null } async addEntry(e) { let t = (await this.getDb()).transaction(ew, "readwrite", { durability: "relaxed" }); await t.store.add(e), await t.done } async getFirstEntryId() { let e = await this.getDb(), t = await e.transaction(ew).store.openCursor(); return null == t ? void 0 : t.value.id } async getAllEntriesByQueueName(e) { let t = await this.getDb(); return await t.getAllFromIndex(ew, eg, IDBKeyRange.only(e)) || [] } async getEntryCountByQueueName(e) { return (await this.getDb()).countFromIndex(ew, eg, IDBKeyRange.only(e)) } async deleteEntry(e) { let t = await this.getDb(); await t.delete(ew, e) } async getFirstEntryByQueueName(e) { return await this.getEndEntryFromIndex(IDBKeyRange.only(e), "next") } async getLastEntryByQueueName(e) { return await this.getEndEntryFromIndex(IDBKeyRange.only(e), "prev") } async getEndEntryFromIndex(e, t) { let s = await this.getDb(), a = await s.transaction(ew).store.index(eg).openCursor(e, t); return null == a ? void 0 : a.value } async getDb() { return this._db || (this._db = await P("workbox-background-sync", 3, { upgrade: this._upgradeDb })), this._db } _upgradeDb(e, t) { t > 0 && t < 3 && e.objectStoreNames.contains(ew) && e.deleteObjectStore(ew), e.createObjectStore(ew, { autoIncrement: !0, keyPath: "id" }).createIndex(eg, eg, { unique: !1 }) } } class em { constructor(e) { this._queueName = e, this._queueDb = new ey } async pushEntry(e) { delete e.id, e.queueName = this._queueName, await this._queueDb.addEntry(e) } async unshiftEntry(e) { let t = await this._queueDb.getFirstEntryId(); t ? e.id = t - 1 : delete e.id, e.queueName = this._queueName, await this._queueDb.addEntry(e) } async popEntry() { return this._removeEntry(await this._queueDb.getLastEntryByQueueName(this._queueName)) } async shiftEntry() { return this._removeEntry(await this._queueDb.getFirstEntryByQueueName(this._queueName)) } async getAll() { return await this._queueDb.getAllEntriesByQueueName(this._queueName) } async size() { return await this._queueDb.getEntryCountByQueueName(this._queueName) } async deleteEntry(e) { await this._queueDb.deleteEntry(e) } async _removeEntry(e) { return e && await this.deleteEntry(e.id), e } } let e_ = ["method", "referrer", "referrerPolicy", "mode", "credentials", "cache", "redirect", "integrity", "keepalive"]; class eb { static async fromRequest(e) { let t = { url: e.url, headers: {} }; for (let [s, a] of ("GET" !== e.method && (t.body = await e.clone().arrayBuffer()), e.headers.entries())) t.headers[s] = a; for (let s of e_) void 0 !== e[s] && (t[s] = e[s]); return new eb(t) } constructor(e) { "navigate" === e.mode && (e.mode = "same-origin"), this._requestData = e } toObject() { let e = Object.assign({}, this._requestData); return e.headers = Object.assign({}, this._requestData.headers), e.body && (e.body = e.body.slice(0)), e } toRequest() { return new Request(this._requestData.url, this._requestData) } clone() { return new eb(this.toObject()) } } let eE = "workbox-background-sync", eR = new Set, ex = e => { let t = { request: new eb(e.requestData).toRequest(), timestamp: e.timestamp }; return e.metadata && (t.metadata = e.metadata), t }; class eq { constructor(e, { forceSyncFallback: t, onSync: s, maxRetentionTime: a } = {}) { if (this._syncInProgress = !1, this._requestsAddedDuringSync = !1, eR.has(e)) throw new u("duplicate-queue-name", { name: e }); eR.add(e), this._name = e, this._onSync = s || this.replayRequests, this._maxRetentionTime = a || 10080, this._forceSyncFallback = !!t, this._queueStore = new em(this._name), this._addSyncListener() } get name() { return this._name } async pushRequest(e) { await this._addRequest(e, "push") } async unshiftRequest(e) { await this._addRequest(e, "unshift") } async popRequest() { return this._removeRequest("pop") } async shiftRequest() { return this._removeRequest("shift") } async getAll() { let e = await this._queueStore.getAll(), t = Date.now(), s = []; for (let a of e) { let e = 6e4 * this._maxRetentionTime; t - a.timestamp > e ? await this._queueStore.deleteEntry(a.id) : s.push(ex(a)) } return s } async size() { return await this._queueStore.size() } async _addRequest({ request: e, metadata: t, timestamp: s = Date.now() }, a) { let r = { requestData: (await eb.fromRequest(e.clone())).toObject(), timestamp: s }; switch (t && (r.metadata = t), a) { case "push": await this._queueStore.pushEntry(r); break; case "unshift": await this._queueStore.unshiftEntry(r) }this._syncInProgress ? this._requestsAddedDuringSync = !0 : await this.registerSync() } async _removeRequest(e) { let t; let s = Date.now(); switch (e) { case "pop": t = await this._queueStore.popEntry(); break; case "shift": t = await this._queueStore.shiftEntry() }if (t) { let a = 6e4 * this._maxRetentionTime; return s - t.timestamp > a ? this._removeRequest(e) : ex(t) } } async replayRequests() { let e; for (; e = await this.shiftRequest();)try { await fetch(e.request.clone()) } catch (t) { throw await this.unshiftRequest(e), new u("queue-replay-failed", { name: this._name }) } } async registerSync() { if ("sync" in self.registration && !this._forceSyncFallback) try { await self.registration.sync.register(`${eE}:${this._name}`) } catch (e) { } } _addSyncListener() { "sync" in self.registration && !this._forceSyncFallback ? self.addEventListener("sync", e => { if (e.tag === `${eE}:${this._name}`) { let t = async () => { let t; this._syncInProgress = !0; try { await this._onSync({ queue: this }) } catch (e) { if (e instanceof Error) throw e } finally { this._requestsAddedDuringSync && !(t && !e.lastChance) && await this.registerSync(), this._syncInProgress = !1, this._requestsAddedDuringSync = !1 } }; e.waitUntil(t()) } }) : this._onSync({ queue: this }) } static get _queueNames() { return eR } } class ev { constructor(e, t) { this.fetchDidFail = async ({ request: e }) => { await this._queue.pushRequest({ request: e }) }, this._queue = new eq(e, t) } } self.skipWaiting(), self.addEventListener("activate", () => self.clients.claim()); let eD = [{ 'revision': 'e9cc022f81d3c24ee1802c8eabf17f10', 'url': '/_next/app-build-manifest.json' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/173-3ed11e004f9a762c.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/23-e891553325128c43.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/231-e147733d2fd662bd.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/(auth)/account/page-cd65e551fdb1a83c.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/(auth)/admin/page-ebc8357b6aef7d90.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/(auth)/forgot-password/page-74484928748a445c.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/(auth)/login/page-9f100ba7145e689e.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/(auth)/register/page-bcc870f6899cfd48.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/_not-found/page-b7aaddc21033d386.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/about/company/page-21eacfdd5f27f8f6.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/about/page-a6a9deef26bb07cc.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/appointments/page-095ecc79ac823334.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/blog/%5Bslug%5D/page-7564c60b61450359.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/blog/layout-86edbe7e8c6d883e.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/blog/page-4bb5906cff692db8.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/contact/page-2ed881cc3095fabd.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/error-31dc2a485405413a.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/layout-7c39d929520422d7.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/loading-6d2ebb014408ea97.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/not-found-55070ac1dd1420dc.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/page-ef43aef4657f1db3.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/services/page-b026f0737168568d.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/app/tools/page-0036b0c10ae83f5d.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/fd9d1056-be48aeae6e94b8d1.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/framework-9e68550641db712d.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/main-app-f4d749a86f613653.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/main-b04473a146044a32.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/pages/_app-6a626577ffa902a4.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/pages/_error-1be831200e60c5c0.js' }, { 'revision': '79330112775102f91e1010318bae2bd3', 'url': '/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js' }, { 'revision': 'reh3MPiBmyejqBCM0CsYp', 'url': '/_next/static/chunks/webpack-a43d4d6b8e16311d.js' }, { 'revision': '74e0bace0b1a76b1', 'url': '/_next/static/css/74e0bace0b1a76b1.css' }, { 'revision': 'a5cb7ac9802e058c', 'url': '/_next/static/css/a5cb7ac9802e058c.css' }, { 'revision': 'f1b44860c66554b91f3b1c81556f73ca', 'url': '/_next/static/media/05a31a2ca4975f99-s.woff2' }, { 'revision': 'c4eb7f37bc4206c901ab08601f21f0f2', 'url': '/_next/static/media/513657b02c5c193f-s.woff2' }, { 'revision': 'bb9d99fb9bbc695be80777ca2c1c2bee', 'url': '/_next/static/media/51ed15f9841b9f9d-s.woff2' }, { 'revision': '74c3556b9dad12fb76f84af53ba69410', 'url': '/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2' }, { 'revision': 'dd930bafc6297347be3213f22cc53d3e', 'url': '/_next/static/media/d6b16ce4a6175f26-s.woff2' }, { 'revision': '0e89df9522084290e01e4127495fae99', 'url': '/_next/static/media/ec159349637c90ad-s.woff2' }, { 'revision': '71f3fcaf22131c3368d9ec28ef839831', 'url': '/_next/static/media/fd4db3eb5472fc27-s.woff2' }, { 'revision': '2ec694eb52ae4f523f265a46bae4d768', 'url': '/_next/static/reh3MPiBmyejqBCM0CsYp/_buildManifest.js' }, { 'revision': 'b6652df95db52feb4daf4eca35380933', 'url': '/_next/static/reh3MPiBmyejqBCM0CsYp/_ssgManifest.js' }, { 'revision': '99804be016a98fe945d3b37be8d0a5ab', 'url': '/fallback.js' }, { 'revision': '4ccc1dec73338769da884cfd41a80aab', 'url': '/favicon.ico' }, { 'revision': 'd22aaaad6a848eb9074f761400d2c4e3', 'url': '/images/ITExpertNow_Logo.svg' }, { 'revision': 'b79adc141b154249ce46c5ac19f8ea57', 'url': '/images/about.png' }, { 'revision': '403f729390117cb057562f101dfcfa7e', 'url': '/images/amex.svg' }, { 'revision': '0e494cd4e75b5aa8264e30947d3978be', 'url': '/images/brands.png' }, { 'revision': '4e5f6c539e80f02c595d8ebd548ff925', 'url': '/images/contact.png' }, { 'revision': '7e199aa23a61191d80e19d4f985cf0f9', 'url': '/images/hero.gif' }, { 'revision': 'ee0aa7292b6c836ef33b04a7b4ab0171', 'url': '/images/landing-hero.svg' }, { 'revision': '5965869114edf1d1cc39ebc43e326f24', 'url': '/images/mastercard.svg' }, { 'revision': '0e9591ff23d095b25b4d8b057a8bb9ba', 'url': '/images/menu.png' }, { 'revision': '8e061864f388b47f33a1c3780831193e', 'url': '/images/next.svg' }, { 'revision': '7a002dc6a7d1141f419ee440fc8549bc', 'url': '/images/noavatar.png' }, { 'revision': '26e611c5088c342f19d8c2f2654be5b1', 'url': '/images/paypal.svg' }, { 'revision': '393863b15703ca00be30cca5ec7c1649', 'url': '/images/venmo.svg' }, { 'revision': '61c6b19abff40ea7acd577be818f3976', 'url': '/images/vercel.svg' }, { 'revision': '4a153a89743681603a37b5bceb3f9827', 'url': '/images/visa.svg' }, { 'revision': 'b554f636666599306b3071c5ad798cd6', 'url': '/images/zelle.svg' }, { 'revision': '0e1fe5e2b950503ae53036ea64217010', 'url': '/manifest.json' }, { 'revision': '04a8b4c0f77fd409efd697b9df70eb7d', 'url': '/meta/1200x630.png' }, { 'revision': 'b9bc6757849ef1529a3552eefbcd1372', 'url': '/meta/README.md' }, { 'revision': 'c910e540b26b404f94f7a9504249f307', 'url': '/meta/android-chrome-192x192.png' }, { 'revision': 'f21149418a33381178191d551dd63a43', 'url': '/meta/android-chrome-512x512.png' }, { 'revision': 'ef52d18ae3e3aa08f320135547b30f55', 'url': '/meta/apple-touch-icon.png' }, { 'revision': '68c9044fa4a08749efb85bb2a4edaede', 'url': '/meta/browserconfig.xml' }, { 'revision': 'd04b810851d7d98e74cf0c2e39edbd7d', 'url': '/meta/favicon-16x16.png' }, { 'revision': 'a2f21cdb3956151c32f11bcfef873b16', 'url': '/meta/favicon-32x32.png' }, { 'revision': '4ccc1dec73338769da884cfd41a80aab', 'url': '/meta/favicon.ico' }, { 'revision': '16fcc6706240a4f3af948d6481787576', 'url': '/meta/favicon.svg' }, { 'revision': 'bc35b9ad5dd77d53729e573e1c714318', 'url': '/meta/html_code.html' }, { 'revision': '6acc60502216e5248f9ecf0738051282', 'url': '/meta/mstile-144x144.png' }, { 'revision': '893c8847a7bb9d5b61ad5a44f8d8f37b', 'url': '/meta/mstile-150x150.png' }, { 'revision': 'd3ef2a4f0f21871fa7b2c9e919fc28ae', 'url': '/meta/mstile-310x150.png' }, { 'revision': 'bbd429150da2ce1a6babf694bba08dc7', 'url': '/meta/mstile-310x310.png' }, { 'revision': '2a48cfd54f336251b7795fd5bb20af7e', 'url': '/meta/mstile-70x70.png' }, { 'revision': 'cb79f493cfbe4a337ba8b27d20a66a0b', 'url': '/meta/safari-pinned-tab.svg' }, { 'revision': '9a57352533b160a6662fe6e2ae5d166d', 'url': '/meta/site.webmanifest' }, { 'revision': '5e14c83d0900380e74c0f585e51e053a', 'url': '/meta/sitemap.xml' }, { 'revision': '616bed0072d0ebd9bb2147e2d1e39c8b', 'url': '/sitemap.xml' }, { 'revision': '769321c904ee6f5c47f2145aae8082d9', 'url': '/sw.js' }]; eD.push({ url: "/fallback", revision: "1234567890" }), eh().precache(eD), e = void 0, ei(new eu(eh(), e)), self.addEventListener("activate", e => { let t = w(); e.waitUntil(ef(t).then(e => { })) }); let eC = new ev("post-api-cache", { maxRetentionTime: 1440 }); ei("/", new X({ cacheName: "start-url", plugins: [new Q({ maxEntries: 1, maxAgeSeconds: 86400, purgeOnQuotaError: !0 })] }), "GET"), ei(/^https:\/\/fonts\.(?:googleapis|gstatic)\.com\/.*/i, new z({ cacheName: "google-fonts", plugins: [new Q({ maxEntries: 4, maxAgeSeconds: 31536e3, purgeOnQuotaError: !0 })] }), "GET"), ei(/\.(?:eot|otf|ttc|ttf|woff|woff2|font.css)$/i, new Z({ cacheName: "static-font-assets", plugins: [new Q({ maxEntries: 4, maxAgeSeconds: 604800, purgeOnQuotaError: !0 })] }), "GET"), ei(/\.(?:jpg|jpeg|gif|png|svg|ico|webp)$/i, new Z({ cacheName: "static-image-assets", plugins: [new Q({ maxEntries: 64, maxAgeSeconds: 86400, purgeOnQuotaError: !0 })] }), "GET"), ei(/\.(?:js)$/i, new Z({ cacheName: "static-js-assets", plugins: [new Q({ maxEntries: 32, maxAgeSeconds: 86400, purgeOnQuotaError: !0 })] }), "GET"), ei(/\.(?:css|less)$/i, new Z({ cacheName: "static-style-assets", plugins: [new Q({ maxEntries: 32, maxAgeSeconds: 86400, purgeOnQuotaError: !0 })] }), "GET"), ei(/\.(?:json|xml|csv)$/i, new X({ cacheName: "static-data-assets", plugins: [new Q({ maxEntries: 32, maxAgeSeconds: 86400, purgeOnQuotaError: !0 })] }), "GET"), ei(/\/api\/.*$/i, new X({ cacheName: "apis", networkTimeoutSeconds: 10, plugins: [new Q({ maxEntries: 16, maxAgeSeconds: 86400, purgeOnQuotaError: !0 })] }), "GET"), ei(/\/api\/.*$/i, new Y({ cacheName: "apis-posts", networkTimeoutSeconds: 10, plugins: [eC] }), "POST"), ei(/.*/i, new X({ cacheName: "others", networkTimeoutSeconds: 10, plugins: [new Q({ maxEntries: 32, maxAgeSeconds: 86400, purgeOnQuotaError: !0 })] }), "GET"), t = new Z, er().setDefaultHandler(t), a = e => { let { event: t } = e; switch (t.request.destination) { case "document": return ep("/fallback"); case "image": return ep("/static/images/fallback.png"); default: return Response.error() } }, er().setCatchHandler(a)
    }()
}();